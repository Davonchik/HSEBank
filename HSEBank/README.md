# КПО-КР-№1
## Выполнено студентом БПИ238, Асланян Давид

## 1. Общая идея решения

В данном проекте реализован модуль «Учет финансов», который предоставляет функциональность для работы с основными доменными объектами:
- **Банковские счета (BankAccount)**
- **Категории (Category)**
- **Операции (Operation)** (доходы/расходы)

Приложение представляет собой консольное приложение, позволяющее пользователю создавать, редактировать, удалять и просматривать финансовые данные, а также проводить аналитические расчёты (например, подсчёт разницы между доходами и расходами, группировка операций по категориям). Помимо этого, реализована возможность импорта и экспорта данных в форматах JSON, CSV и YAML.

Решение построено по принципам SOLID и GRASP (High Cohesion, Low Coupling), а также использует ряд паттернов GoF, что обеспечивает гибкость, расширяемость и простоту поддержки системы.

---

## 2. Реализованные паттерны

### 2.1. Фабрика (Factory Pattern)
- **Реализация:** Класс `FinancialFactory`
- **Назначение:** Централизованное создание доменных объектов (BankAccount, Category, Operation) с валидацией входных данных.
- **Преимущество:** Избегание дублирования логики создания объектов, единообразие и возможность лёгкого расширения при необходимости.

### 2.2. Фасад (Facade Pattern)
- **Реализация:** Отдельные фасады для работы с сущностями (`AccountFacade`, `CategoryFacade`, `OperationFacade`) и главный фасад `FinancialFacade`, который объединяет их и предоставляет единый интерфейс для пользователя.
- **Назначение:** Сокрытие сложностей взаимодействия с внутренними сервисами и предоставление простого API для консольного приложения.
- **Преимущество:** Высокая связанность внутри фасадов и низкая связанность между модулями, что соответствует принципам GRASP.

### 2.3. Прокси (Proxy Pattern)
- **Реализация:** Прокси-обёртка для аналитического сервиса – например, `AnalyticsServiceLoggerProxy`.
- **Назначение:** Логирование и измерение времени выполнения аналитических операций без вмешательства в основную бизнес-логику.
- **Преимущество:** Отделение вспомогательных задач (логирование, аудит) от основного функционала.

### 2.4. Посетитель (Visitor Pattern)
- **Реализация:** Экспортеры данных, такие как `JsonAggregateExportVisitor`, `CsvAggregateExportVisitor` и `YamlAggregateExportVisitor`.
- **Назначение:** Экспорт данных без изменения классов доменной модели. Каждый доменный объект реализует метод `Accept`, через который посетитель добавляет данные для последующего экспорта в нужном формате.
- **Преимущество:** Лёгкое расширение функционала экспорта при добавлении новых форматов.

### 2.5. Шаблонный метод (Template Method Pattern)
- **Реализация:** Импортеры данных – `JsonDataImporter`, `CsvDataImporter`, `YamlDataImporter`.
- **Назначение:** Общий алгоритм импорта данных (чтение файла, десериализация) с различной реализацией парсинга для каждого формата.
- **Преимущество:** Упрощает расширение функционала для новых форматов без изменения общей логики импорта.

### 2.6. Синглтон (Singleton Pattern)
- **Реализация:** Главный фасад `FinancialFacade` реализован как синглтон.
- **Назначение:** Гарантировать наличие единственного экземпляра фасада, координирующего работу системы.
- **Преимущество:** Централизованное управление всеми операциями и бизнес-логикой в приложении.

### 2.7. Репозиторий (Repository Pattern)
- **Реализация:** Репозитории для доступа к данным, такие как `AccountRepository`, `CategoryRepository`, `OperationRepository`.
- **Назначение:** Предоставление стандартных CRUD-операций над доменными объектами, абстрагируя детали хранения данных (in‑memory или БД).
- **Преимущество:** Упрощает замену механизма хранения данных без изменений в бизнес-логике.

---

## 3. Соблюдение принципов SOLID и GRASP

### SOLID
- **SRP (Single Responsibility):**  
  Каждый класс имеет одну ответственность: фабрика создаёт объекты, фасады инкапсулируют логику работы с конкретной сущностью, репозитории – доступ к данным, а аналитический сервис – обработку аналитики.
- **OCP (Open-Closed):**  
  Система расширяема – можно добавлять новые импортеры/экспортеры без изменения существующего кода фасадов или репозиториев.
- **LSP (Liskov Substitution):**  
  Интерфейсы позволяют заменять реализации (например, in‑memory или с использованием БД) без нарушения логики.
- **ISP (Interface Segregation):**  
  Интерфейсы разбиты на узкоспециализированные, что позволяет клиентским модулям зависеть только от необходимых методов.
- **DIP (Dependency Inversion):**  
  Высокоуровневые модули зависят от абстракций, а не от конкретных реализаций, что облегчает тестирование и замену компонентов.

## Объяснение настроек DI

**Фасады и репозитории:**  
Регистрация фасадов (`IAccountFacade`, `ICategoryFacade`, `IOperationFacade`) и репозиториев (`IAccountRepository`, `ICategoryRepository`, `IOperationRepository`) выполняется с помощью `AddScoped`. Это означает, что для каждого запроса (например, при вызове из консольного приложения) создаётся новый экземпляр, что удобно для работы с in‑memory хранилищами или при использовании БД.

**Фабрика:**  
`IFinancialFactory` регистрируется для централизованного создания объектов доменной модели. Фабрика инкапсулирует в себе логику создания объектов и их валидации, что помогает избежать дублирования кода в других частях приложения.

**Аналитический сервис и его прокси:**  
Базовый `AnalyticsService` регистрируется отдельно, а затем для интерфейса `IAnalyticsService` создаётся прокси (`AnalyticsServiceLoggerProxy`), который оборачивает базовый сервис. Прокси отвечает за логирование и измерение времени выполнения аналитических операций, не вмешиваясь в основную бизнес-логику.

**Главный фасад (FinancialFacade):**  
Главный фасад регистрируется как синглтон через метод `GetInstance`. Он объединяет в себе функциональность всех нижестоящих фасадов и предоставляет единый интерфейс для взаимодействия с пользователем. Такой подход упрощает управление бизнес-логикой и позволяет централизованно обрабатывать все финансовые операции.

Эта конфигурация DI обеспечивает:
- **Инверсию зависимостей (DIP):** Компоненты зависят от абстракций (интерфейсов), а не от конкретных реализаций, что упрощает тестирование и замену компонентов.
- **Низкую связанность:** Каждый компонент системы зарегистрирован отдельно и взаимодействует через интерфейсы, что позволяет легко модифицировать или расширять функциональность без влияния на остальные части системы.
- **Централизованное управление зависимостями:** DI-контейнер автоматически создаёт и внедряет нужные зависимости, избавляя от необходимости ручного создания объектов.


### GRASP
- **High Cohesion:**  
  Каждый модуль отвечает за свою узкую задачу, что улучшает читаемость и сопровождение кода.
- **Low Coupling:**  
  Модули взаимодействуют через интерфейсы и фасады, что снижает взаимозависимость и упрощает модификацию отдельных частей системы.

---

## 4. Инструкция по запуску приложения

1. **Клонирование репозитория:**  
   Склонируйте проект с GitHub (или другого источника).

2. **Восстановление NuGet-пакетов:**  
   В корневой папке проекта выполните команду:


---
1. Разработать классы доменной модели модуля «Учет финансов». Доменная модель классов должна быть реализована с соблюдением принципов SOLID, ключевыми идеями GRASP: High Cohesion и Low Coupling, а также рядом паттернов GoF: порождающих; структурных и поведенческих.
2. Создать консольное приложение, в котором продемонстрировать функциональность разработанной доменной модели через взаимодействие с пользователем.
3. Написать отчет, в котором отразить:
   a. Общую идею вашего решения (какой функционал реализовали, особенно
   если вносили изменения в функциональные требования).
   b. Опишите какие принципы из SOLID и GRASP вы реализовали, скажите в
   каких классах (модулях).
   c. Опишите какие паттерны GoF вы реализовали, обоснуйте их важность,
   скажите в каких классах (модулях) они реализованы.
   Отчет пишется в свободной форме (например, redme-файл к проекту в формате md). Задача отчета помочь проверяющему увидеть всё, что вы реализовали.
4. Добавить инструкция по запуску вашего приложения.

---

### **Пояснения:**
1. 
---

---


# 📌 Unit тесты
Тесты написаны в отдельном проекте `TestMiniHW` данного решения `miniHW_1_AslanyanDG`

Использовался фреймворк для модульного тестирования **`xUnit`**

Использовались `Theory` и `Fact` атрибуты для тестов.

Покрытие бизнес-логики (Service, Models) проекта составило 100%, что больше требуемых в доп.задаче 60%

![img.png](img.png)
применялся интерфейс test coverage для просмотра процента покрытия тестами.

